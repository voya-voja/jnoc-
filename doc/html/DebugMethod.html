<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML>
<HEAD>
   <TITLE>class  inexum::util::DebugMethod</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.10">
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2>class  <A HREF="#DOC.DOCU">inexum::util::DebugMethod</A></H2></H2><BLOCKQUOTE>Class method debug statement.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CDebug,MDebug.html,CDebugFunction,MDebugFunction.html,CDebugMethod,MDebugMethod.html">
<param name=before value="M,M,M">
<param name=after value="Md_SP,Md_,M">
<param name=indent value="0,1,2">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.3.3.1">DebugMethod</A></B>(int mode, const std::string&amp; <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A>, const std::string&amp; methodName)
<DD><I>Overloaded constructor allows definition of debug statement for a class method without arguments and return value.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.3.3.2">DebugMethod</A></B>(const std::string&amp; <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A>, const std::string&amp; methodName, const char* formatMsg, ...)
<DD><I>Overloaded constructor allows definition of class and method name, return  object and variable list of arguments for the method.</I>
<DT>
<IMG ALT="[more]" BORDER=0 SRC=icon1.gif> <B><A HREF="#DOC.1.3.3.3">DebugMethod</A></B>(int mode, const std::string&amp; <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A>, const std::string&amp; methodName, const char* formatMsg, ...)
<DD><I>Overloaded constructor allows definition of class and method name, return  object and variable list of arguments for the method.</I>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="DebugFunction.html">DebugFunction</A>:</H3>
<DL>
<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>void <B>print</B>(const std::string&amp; formatMsg, va_list&amp; argList)
<DT>
<IMG ALT="o" SRC=icon2.gif>std::string <B>format</B>(const std::string&amp; formatMsg, va_list&amp; argList )
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="Debug.html">Debug</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>addMode</B>(int mode)
<DT>
<IMG ALT="o" SRC=icon2.gif>static   <!1><A HREF="Debug.html#DOC.1.3.1.1">Mode</A> <B>getMode</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>static   ostream&amp; <B>output</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>increaseIndent</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>static   void <B>decreaseIndent</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>static   const std::string&amp; <B>indent</B>()
<DT>
<IMG ALT="o" SRC=icon2.gif>ostream&amp; <B>output</B>(const std::string&amp; msg)
<DT>
<IMG ALT="o" SRC=icon2.gif>virtual   ostream&amp; <B>output</B>(const char* formatMsg, ...)
<DT>
<IMG ALT="o" SRC=icon2.gif>const std::string&amp; <B>preMessage</B>() const 
<DT>
<IMG ALT="o" SRC=icon2.gif>const std::string&amp; <B>postMessage</B>() const 
</DL></P>

<P><DL>
<DT><H3>Public Members</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>enum  <B>Mode</B>
</DL></P>

<P><DL>
<DT><H3>Protected Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>std::string <B>time</B>() const 
</DL></P>

</DL>

<A NAME="DOC.DOCU"></A>
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Class method debug statement. The instance should be created at the 
begining of the method, with return object and argument list. At the 
place of instance creation prints debug statement in following format:

<P>&lt;class name&gt;::&lt;method name&gt;([&lt;argument&gt; : &lt;value&gt;[,]]*) 

<P>At the end of the function prints debug statement in following format:

<P>&lt;class name&gt;::&lt;method name&gt;(return : &lt;value&gt;|"NO return")

<P></BLOCKQUOTE>
<DL>

<A NAME="DebugMethod"></A>
<A NAME="DOC.1.3.3.1"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> DebugMethod(int mode, const std::string&amp; <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A>, const std::string&amp; methodName)</B></TT>
<DD>Overloaded constructor allows definition of debug statement for a class
method without arguments and return value.

<P>
<DL><DT><DT><B>Parameters:</B><DD><B>mode</B> -  - debug statement mode.
<BR><B></B> - <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A> - class <!1><A HREF="Member.html#DOC.1.1.12.7">name</A> string.
<BR><B>methodName</B> -  - method <!1><A HREF="Member.html#DOC.1.1.12.7">name</A> string.<BR><DD></DL><P>
<A NAME="DebugMethod"></A>
<A NAME="DOC.1.3.3.2"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> DebugMethod(const std::string&amp; <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A>, const std::string&amp; methodName, const char* formatMsg, ...)</B></TT>
<DD>Overloaded constructor allows definition of class and method name, return 
object and variable list of arguments for the method. It uses printf() 
formated message, extended for %D referencing to a Debug instance. If the 
function returns an object, the format message has to start (without space) 
with the definition type of the return object and the reference to the 
return object has to be specified first in the variable argument list, e.g.:

<P>int MyClass::myMethod(double amount, MyClass2&amp; obj) {

<P>int retValue = -1;	 initialize return variable

<P>DebugFunction debugStm("MyClass", "myMethod", 
"%d amount: %5.3f, object: %D", 
&amp;retValue, amount, &amp;DebugClass&lt;MyCLass2&gt;(obj));

<P>...

<P>return(retValue);

<P>}

<P>Only if the debug mode includes c_base, the debug log output will be:

<P>...

<P>&lt;date time&gt; MyClass::myMethod(amount: 1.321, object: MyClass{ x: 2 })

<P>...

<P>&lt;date time&gt; MyClass::myMethod(return: 0)

<P>...

<P>
<DL><DT><DT><B>Parameters:</B><DD><B></B> - <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A> - class <!1><A HREF="Member.html#DOC.1.1.12.7">name</A> string.
<BR><B>methodName</B> -  - method <!1><A HREF="Member.html#DOC.1.1.12.7">name</A> string.
<BR><B>formatMsg</B> -  - printf() <!1><A HREF="DebugFunction.html#DOC.1.3.2.7">format</A> message, extended for %D referencing 
<!1><A HREF="Debug.html">Debug</A> instance. If function returns a <!1><A HREF="StringObject.html#DOC.1.1.27.5">value</A> the <!1><A HREF="DebugFunction.html#DOC.1.3.2.7">format</A> 
message has to start without spaces with the <!1><A HREF="ClassObject.html#DOC.1.1.7.14">type</A> of the 
return type.
<BR><B>...</B> -  - variable argument list. If the function has a return <!1><A HREF="StringObject.html#DOC.1.1.27.5">value</A>
the first argument has to be <!1><A HREF="Member.html#DOC.1.1.12.4">address</A> of the return object.<BR><DD></DL><P>
<A NAME="DebugMethod"></A>
<A NAME="DOC.1.3.3.3"></A>
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> DebugMethod(int mode, const std::string&amp; <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A>, const std::string&amp; methodName, const char* formatMsg, ...)</B></TT>
<DD>Overloaded constructor allows definition of class and method name, return 
object and variable list of arguments for the method. It uses printf() 
formated message, extended for %D referencing to a Debug instance. If the 
function returns an object, the format message has to start (without space)
with the definition type of the return object and the reference to the 
return object has to be specified first in the variable argument list, e.g.:

<P>int MyClass::myMethod(double amount, MyClass2&amp; obj) {

<P>int retValue = -1;	 initialize return variable

<P>DebugFunction debugStm(Debug::c_ui, "MyClass", "myMethod", 
"%d amount: %5.3f, object: %D", 
&amp;retValue, amount, &amp;DebugClass&lt;MyCLass2&gt;(obj));

<P>...

<P>return(retValue);

<P>}

<P>Only if the debug mode includes c_ui, the debug log output will be:

<P>...

<P>&lt;date time&gt; MyClass::myMethod(amount: 1.321, object: MyClass{ x: 2 })

<P>...

<P>&lt;date time&gt; MyClass::myMethod(return: 0)

<P>...

<P>
<DL><DT><DT><B>Parameters:</B><DD><B>mode</B> -  - debug statement mode.
<BR><B></B> - <!1><A HREF="Serializable.html#DOC.1.1.17.8">className</A> - class <!1><A HREF="Member.html#DOC.1.1.12.7">name</A> string.
<BR><B>methodName</B> -  - method <!1><A HREF="Member.html#DOC.1.1.12.7">name</A> string.
<BR><B>formatMsg</B> -  - printf() <!1><A HREF="DebugFunction.html#DOC.1.3.2.7">format</A> message, extended for %D referencing 
<!1><A HREF="Debug.html">Debug</A> instance. If function returns a <!1><A HREF="StringObject.html#DOC.1.1.27.5">value</A> the <!1><A HREF="DebugFunction.html#DOC.1.3.2.7">format</A> 
message has to start without spaces with the <!1><A HREF="ClassObject.html#DOC.1.1.7.14">type</A> of the 
return type.
<BR><B>...</B> -  - variable argument list. If the function has a return <!1><A HREF="StringObject.html#DOC.1.1.27.5">value</A>
the first argument has to be <!1><A HREF="Member.html#DOC.1.1.12.4">address</A> of the return object.<BR><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DT><B>Author:</B><DD>iNexum Systems Inc.

<DT><B>Version:</B><DD>1.0.0
<DD></DL><P><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I></P><HR>
<BR>
This page was generated with the help of <A HREF="http://docpp.sourceforge.net">DOC++</A>.
</BODY>
</HTML>
